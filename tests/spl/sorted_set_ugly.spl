struct Node {
  var next: Node;
  var data: int;
}

predicate sorted_set(x: Node, y: Node, lb: int, ub: int, c: set<Node>) {
    x == y &*&
    c == set<Node>()
  || 
    x != y &*&
    acc(x) &*&
    x in c &*&
    lb <= x.data &*&
    x.data <= ub &*&
    sorted_set(x.next, y, x.data+1, ub, c -- set(x))
}

procedure traverse(lst: Node, ghost lb: int, ghost ub: int, ghost content: set<Node>)
  requires sorted_set(lst, null, lb, ub, content);
  ensures sorted_set(lst, null, lb, ub, content);
{
  if (lst == null) {
    return ;
  }

  var curr: Node;
  curr := lst;
  var c1: set<Node>, c2: set<Node>;
  c1 := content;
  c2 := set<Node>();

  while (curr.next != null) 
    invariant (curr != null &*& sorted_set(lst, curr, lb, curr.data, c2) &*& sorted_set(curr, null, curr.data, ub, c1))
           || (curr == null &*& sorted_set(lst, curr, lb, ub, c2) &*& c1 == set<Node>());
    invariant content == c1 ++ c2;
    invariant curr.data <= ub && lb <= curr.data;
  {
    c2 := c2 ++ set<Node>(curr);
    c1 := c1 -- set<Node>(curr);
    curr := curr.next; 
  }
}

procedure mem(lst: Node, val: Node,
              ghost lb: int, ghost ub: int, ghost content: set<Node>)
  returns (res: bool)
  requires sorted_set(lst, null, lb, ub, content) &+& acc(val);
  ensures  sorted_set(lst, null, lb, ub, content) &+& acc(val);
  ensures  ((res == true) && val in content) || ((res == false) && !(val in content));
{
  if (lst == null) {
    return false;
  }

  var curr: Node;
  curr := lst;
  var c1: set<Node>, c2: set<Node>;
  c1 := content;
  c2 := set<Node>();

  while (curr.next != null && curr != val && curr.data <= val.data) 
    invariant (sorted_set(lst, curr, lb, curr.data, c2)
          &*& sorted_set(curr, null, curr.data, ub, c1))
          &+& acc(val);
    invariant curr.data <= ub && lb <= curr.data;
    invariant content == c1 ++ c2;
    invariant !(val in c2);
  {
    c2 := c2 ++ set(curr);
    c1 := c1 -- set(curr);
    curr := curr.next; 
  }
  if (curr != null && curr == val) return true;
  else return false;
}

procedure insert(lst: Node, elt: Node,
                 ghost lb: int, ghost ub: int, ghost content: set<Node>)
  returns (res: Node)
  requires sorted_set(lst, null, lb, ub, content) &+& acc(elt);
  requires elt.data <= ub &*& elt.data >= lb;
  ensures sorted_set(res, null, lb, ub, content ++ set<Node>(elt));
{
  if (lst == null || lst.data > elt.data) {
    elt.next := lst;
    return elt;
  } else {
    var curr: Node;
    curr := lst;
    var c1: set<Node>, c2: set<Node>;
    c1 := content;
    c2 := set<Node>();
    while (curr.next != null && curr.next.data <= elt.data) 
      invariant curr != null;
      invariant sorted_set(lst, curr, lb, curr.data, c2);
      invariant sorted_set(curr, null, curr.data, ub, c1);
      invariant curr.data <= elt.data;
      invariant curr.data <= ub && lb <= curr.data;
      invariant content == c1 ++ c2;
    {
      curr := curr.next;
      c2 := c2 ++ set(curr);
      c1 := c1 -- set(curr);
    }
    if (curr != elt) {
      elt.next := curr.next;
      curr.next := elt;
    }
    return lst;
  }
}


procedure remove(lst: Node, value: Node,
                 ghost lb: int, ghost ub: int, ghost content: set<Node>)
  returns (res: Node)
  requires sorted_set(lst, null, lb, ub, content) &+& acc(value);
  ensures sorted_set(res, null, lb, ub, content -- set<Node>(value)) &*& acc(value);
{

  if (lst == null || lst.data > value.data)
    return lst;

  var curr: Node, prv: Node;
  prv := lst;
  curr := lst.next;
  var c1: set<Node>, c2: set<Node>;
  c1 := content;
  c2 := set<Node>();

  while (curr.next != null && curr.data <= value.data) 
    invariant (sorted_set(lst, prv, lb, prv.data, c2)
          &*& sorted_set(curr, null, curr.data, ub, c1))
          &+& acc(value);
    invariant prv.next |-> curr;
    invariant content == c1 ++ c2;
    invariant prv.data <= ub && lb <= prv.data;
    invariant curr.data <= ub && lb <= curr.data;
    invariant !(value in c2);
  {
    if (curr == value) {
      c1 := c1 -- set(curr);
      prv := curr.next;
      curr := prv.next;
    } else {
      c2 := c2 ++ set(curr);
      c1 := c1 -- set(curr);
      prv := curr;
      curr := curr.next;
    }
  }

  if (curr != null && curr == value) {
    prv.next := curr.next;
  }
  return lst;
}
