struct Node {
  var next: Node;
}

predicate lseg(x: Node, y: Node, implicit X: set<Node>) {
  x == y && X == {} ||
  x != y &*& x in X &*& acc(x) &*& lseg(x.next, y, X -- {x})
}

procedure find(x: Loc, ghost root_x: Node, implicit ghost X: set<Node>) 
returns (res: Node)
  requires lseg(x, root_x, X) &*& x != null;
  ensures acc(X) &*& (forall x in X. x.next == root_x) &*& res == root_x;
{
  var n: Node;
  n := x.next;
  if (n != null) {
    res := find(n, root_x);
    x.next := res;
  } else {
    res := x;
  }
}

procedure union(x: Node, y: Node, 
                ghost root_x: Node, ghost root_y: Node,
                implicit ghost X: set<Node>, implicit ghost Y: set<Node>)
  requires lseg(x, root_x, X) &+& lseg(y, root_y, Y);
  requires acc(root_x);
  ensures acc(X) &+& acc(Y);
  ensures acc(root_x);
  ensures forall z in X -- Y. z.next == root_x;
  ensures forall z in Y. z.next == root_y;
  ensures root_x == root_y || root_x.next == root_y;
{
  var t: Node;
  var s: Node;
  t := find(x, root_x);
  s := find(y, root_y);
  if (t != s) {
    t.next := s;
  }
}
