include "def.spl";
include "find.spl";

/* is a node full */
procedure is_full(u: Node) returns (res: Bool)
  requires btree_node(u)
  ensures  btree_node(u)
{
  if (u.keys[u.keys.length -1] != bottom) {
    return true;
  } else {
    return false;
  }
}

/* is a node a leaf */
procedure is_leaf(u: Node) returns (res: Bool)
  requires btree_node(u)
  ensures  btree_node(u)
{
  if (u.children[0] == null) {
    return true;
  } else {
    return false;
  }
}

function aux_old_a2(idx: Int) returns (val: T)

procedure key_arraymove(a: Array<T>, srcPos: Int, dstPos: Int, length: Int)
  requires acc(a) &*& (key_arrayseg(a, srcPos, srcPos + length) &+& key_arrayseg(a, dstPos, dstPos + length))
  ensures  acc(a) &*& (key_arrayseg(a, srcPos, srcPos + length) &+& key_arrayseg(a, dstPos, dstPos + length))
  ensures  forall i: Int :: srcPos <= i && i < srcPos + length && (i < dstPos || dstPos + length <= i) ==> a[i] == old(a[i])
  ensures  forall i: Int :: 0 <= i && i < length ==> a[dstPos + i] == old(a[srcPos + i])
           @(matching i yields a[i])
           @(matching i yields old(a[i]))
{
  pure assume forall j: Int :: srcPos <= j && j < srcPos + length ==> a[j] == aux_old_a2(j)
              @(matching j yields aux_old_a2(j));
  if (srcPos < dstPos) {
    var i := length - 1;
    while (i >= 0)
      invariant srcPos < dstPos
      invariant acc(a) &*& (key_arrayseg(a, srcPos, srcPos + length) &+& key_arrayseg(a, dstPos, dstPos + length))
      invariant -1 <= i && i < length
      invariant forall j: Int :: srcPos <= j && j < srcPos + length && j <= dstPos + i ==> a[j] == aux_old_a2(j)
      invariant forall j: Int :: i < j && j < length ==> a[dstPos + j] == aux_old_a2(srcPos + j)
                @(matching j yields aux_old_a2(j))
    {
      a[dstPos + i] := a[srcPos + i];
      i := i - 1;
    }
    return ;
  } else if (srcPos > dstPos){
    var i := 0;
    while (i < length)
      invariant srcPos > dstPos
      invariant acc(a) &*& (key_arrayseg(a, srcPos, srcPos + length) &+& key_arrayseg(a, dstPos, dstPos + length))
      invariant 0 <= i && i <= length 
      invariant forall j: Int :: srcPos <= j && j < srcPos + length && dstPos + i <= j ==> a[j] == aux_old_a2(j)
      invariant forall j: Int :: 0 <= j && j < i ==> a[dstPos + j] == aux_old_a2(srcPos + j)
                @(matching j yields aux_old_a2(j))
    {
      a[dstPos + i] := a[srcPos + i];
      i := i + 1;
    }
    return ;
  }
}

function aux_old_a(idx: Int) returns (val: Node)

procedure node_arraymove(a: Array<Node>, srcPos: Int, dstPos: Int, length: Int)
  requires acc(a) &*& (node_arrayseg(a, srcPos, srcPos + length) &+& node_arrayseg(a, dstPos, dstPos + length))
  ensures  acc(a) &*& (node_arrayseg(a, srcPos, srcPos + length) &+& node_arrayseg(a, dstPos, dstPos + length))
  ensures  forall i: Int :: srcPos <= i && i < srcPos + length && (i < dstPos || dstPos + length <= i) ==> a[i] == old(a[i])
  ensures  forall i: Int :: 0 <= i && i < length ==> a[dstPos + i] == old(a[srcPos + i])
           @(matching i yields a[i])
           @(matching i yields old(a[i]))
{
  pure assume forall j: Int :: srcPos <= j && j < srcPos + length ==> a[j] == aux_old_a(j)
              @(matching j yields aux_old_a(j));
  if (srcPos < dstPos) {
    var i := length - 1;
    while (i >= 0)
      invariant srcPos < dstPos
      invariant acc(a) &*& (node_arrayseg(a, srcPos, srcPos + length) &+& node_arrayseg(a, dstPos, dstPos + length))
      invariant -1 <= i && i < length
      invariant forall j: Int :: srcPos <= j && j < srcPos + length && j <= dstPos + i ==> a[j] == aux_old_a(j)
      invariant forall j: Int :: i < j && j < length ==> a[dstPos + j] == aux_old_a(srcPos + j)
                @(matching j yields aux_old_a(j))
    {
      a[dstPos + i] := a[srcPos + i];
      i := i - 1;
    }
  } else if (srcPos > dstPos){
    var i := 0;
    while (i < length)
      invariant srcPos > dstPos
      invariant acc(a) &*& (node_arrayseg(a, srcPos, srcPos + length) &+& node_arrayseg(a, dstPos, dstPos + length))
      invariant 0 <= i && i <= length 
      invariant forall j: Int :: srcPos <= j && j < srcPos + length && dstPos + i <= j ==> a[j] == aux_old_a(j)
      invariant forall j: Int :: 0 <= j && j < i ==> a[dstPos + j] == aux_old_a(srcPos + j)
                @(matching j yields aux_old_a(j))
    {
      a[dstPos + i] := a[srcPos + i];
      i := i + 1;
    }
  }
}

/* Add the value x to this block
 * @param x     the value to add
 * @param ci    the child associated with x
 * @return      true on success or false if x was not added
 */
procedure addNode(u: Node, x: T, ci: Node) returns (res: Bool)
  requires btree(u) &*& btree(ci)
  requires ci.parent == null && u != null && ci != null
  ensures  btree(u)
{
  var i := findIt(u.keys, x);
  if (i < u.keys.length && u.keys[i] == x) {
    return false;
  } else if (i < u.keys.length-1) {
    key_arraymove(u.keys, i, i+1, b-i-1);
  }
  u.keys[i] := x;
  if (i < u.keys.length-1) {
    node_arraymove(u.children, i+1, i+2, b-i-1);
  }
  u.children[i+1] := ci;
  ci.parent := ci;
  return true;
}

/* Remove the i'th value from this block - don't affect this block's children
 * @param i     the index of the element to remove
 * @return      the value of the element removed
 */
procedure removeNode(u: Node, i: Int) returns (res: T)
  requires btree_node(u)
  requires 0 <= i && i < u.keys.length
  ensures  btree_node(u) //TODO this does not seems right (we change the key but not the values!)
{
  var y := u.keys[i];
  key_arraymove(u.keys, i+1, i, b-i-1);
  u.keys[u.keys.length-1] := bottom;
  return y;
}

procedure newNode() returns (res: Node)
  requires  emp
  ensures   btree_node(res)
{
  var w := new Node();
  w.keys := new Array<T>(b);
  w.children := new Array<Node>(b+1);
  w.parent := null;
  var i := 0;
  while (i < b)
    invariant 0 <= i && i <= b
    invariant acc(w) &*& acc(w.keys) &*& acc(w.children)
    invariant w.keys.length == b && w.children.length == b+1
    invariant key_arrayseg(w.keys, 0, w.keys.length)
    invariant node_arrayseg(w.children, 0, w.children.length)
    invariant forall j: Int :: 0 <= j && j < i ==> w.keys[j] == bottom && w.children[j] == null
  {
    w.keys[i] := bottom;
    w.children[i] := null;
    i := i + 1;
  }
  w.children[b] := null;
  return w;
}
