struct Node {
  var next: Node;
  var data: int;
}


predicate blseg(x: Node, y: Node, lb: int, ub: int) {
  x == y || x != y &*& acc(x) &*& lb <= x.data &*& x.data <= ub &*& blseg(x.next, y, lb, ub)
}

predicate bslseg(x: Node, y: Node, lb: int, ub: int) {
  x == y || x != y &*& acc(x) &*& lb <= x.data &*& x.data <= ub &*& bslseg(x.next, y, x.data, ub)
}


procedure predecessor(start: Node, end: Node, lb: int, ub: int) returns (prv: Node)
    requires blseg(start, end, lb, ub) &*& start != end;
    ensures blseg(start, prv, lb, ub) &*& acc(prv) &*& prv.next == end &*& prv.data >= lb &*& prv.data <= ub;
{
    var prv: Node;
    prv := start;
    var curr: Node;
    curr := start.next;
    while (curr != end)
        invariant blseg(start, prv, lb, ub);
        invariant blseg(curr, end, lb, ub);
        invariant acc(prv) &*& prv.next == curr;
        invariant prv.data >= lb &*& prv.data <= ub;
    {
        prv := curr;
        curr := curr.next;
    }
    return prv;
}

procedure split(lst: Node, tsl: Node, lb: int, ub: int) returns (returned: Node)
    requires blseg(lst, tsl, lb, ub) &*& lst != tsl;
    ensures blseg(lst, returned, lb, returned.data) &*& blseg(returned, tsl, returned.data, ub) &*& returned != tsl;
{
    var pivot: Node;
    pivot := predecessor(lst, tsl, lb, ub);
    if (lst == pivot) {
        return lst;
    } else {
        var last: Node, start: Node, end: Node;
        last := predecessor(lst, pivot, lb, ub);
        start := lst;
        end := last;
        while (start != end)
            invariant blseg(lst, start, lb, pivot.data);
            invariant blseg(start, end, lb, ub);
            invariant blseg(end, last, pivot.data, ub);
            invariant acc(last) &*& last.next == pivot;
            invariant last.data >= lb;
            invariant last.data <= ub;
            invariant acc(pivot) &*& pivot.next == tsl; 
            invariant pivot.data >= lb;
            invariant pivot.data <= ub;
        {
            if (start.data <= pivot.data) {
                start := start.next;
            } else if (end.data > pivot.data) {
                end := predecessor(start, end, lb, ub);
            } else {
                var tmp: int;
                tmp := start.data;
                start.data := end.data;
                end.data := tmp;
            }
        }
        if (start == last) {
            return lst;
        } else if (start == lst) {
            return pivot;
        } else {
            last.next := pivot.next;
            pivot.next := start.next;
            start.next := pivot;
            return lst;
        }
    }
}

procedure quicksort(lst: Node, end: Node, lb: int, ub: int) //returns (lst: Node)
    requires blseg(lst, end, lb, ub);
    ensures bslseg(lst, end, lb, ub);
{
    if (lst == end || lst.next == end) {
    } else {
        var middle: Node;
        middle := split(lst, end, lb, ub);
        quicksort(lst, middle, lb, middle.data);
        quicksort(middle, end, middle.data, ub);
    }
}
