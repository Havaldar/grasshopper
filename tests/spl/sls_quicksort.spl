struct Node {
  var next: Node;
  var data: int;
}


predicate blseg(x: Node, y: Node, lb: int, ub: int) {
  x == y || x != y &*& acc(x) &*& lb <= x.data &*& x.data <= ub &*& blseg(x.next, y, lb, ub)
}

predicate bslseg(x: Node, y: Node, lb: int, ub: int) {
  x == y || x != y &*& acc(x) &*& lb <= x.data &*& x.data <= ub &*& bslseg(x.next, y, x.data, ub)
}


procedure predecessor(start: Node, end: Node, ghost lb: int, ghost ub: int, ghost edata: int) returns (prv: Node)
    requires blseg(start, end, lb, ub) &*&
             start != end &*&
             end.data |-> edata;
    ensures blseg(start, prv, lb, ub) &*&
            acc(prv) &*& prv.next == end &*&
            prv != end &*&
            prv.data >= lb &*& prv.data <= ub &*&
            end.data |-> edata;
{
    var prv: Node;
    prv := start;
    while (prv.next != end)
        invariant blseg(start, prv, lb, ub);
        invariant blseg(prv, end, lb, ub);
        invariant prv != end;
        invariant prv.data >= lb &*& prv.data <= ub;
    {
        prv := prv.next;
    }
    return prv;
}

procedure quicksort(lst: Node, tsl: Node, ghost lb: int, ghost ub: int, ghost tsldata: int) //returns (lst: Node)
    requires blseg(lst, tsl, lb, ub) &*& acc(tsl) &*& tsl.data == tsldata;
    ensures bslseg(lst, tsl, lb, ub) &*& acc(tsl) &*& tsl.data == tsldata;
{
    if (lst == tsl || lst.next == tsl) {
      return ;
    } else {
        var pivot: Node, start: Node, end: Node;
        pivot := predecessor(lst, tsl, lb, ub, tsl.data);
        end := pivot;
        start := lst;
        while (start != end)
            invariant blseg(lst, start, lb, pivot.data);
            invariant blseg(start, end, lb, ub);
            invariant blseg(end, pivot, pivot.data, ub);
            invariant pivot.next |-> tsl; 
            invariant pivot.data >= lb;
            invariant pivot.data <= ub;
        {
            if (start.data <= pivot.data) {
                start := start.next;
            } else if (end.data > pivot.data) {
                end := predecessor(start, end, lb, ub, end.data);
            } else {
                var tmp: int;
                tmp := start.data;
                start.data := end.data;
                end.data := tmp;
            }
        }
        var tmp2: int;
        tmp2 := pivot.data;
        pivot.data := end.data;
        end.data := tmp2;
        pivot := end;
        tmp2 := pivot.data;
        quicksort(lst, pivot, lb, tmp2, tmp2);
        quicksort(pivot.next, tsl, tmp2, ub, tsldata);
        return ;
    }
}
