include "../include/sllist_rec.spl";

procedure lemma(x: Node, y: Node, z: Node)
  requires exists X: Set<Node> :: (lseg(x, y) &*& lseg(y, z)) && acc(X) &*& z !in X
  ensures lseg(x, z)
{
  if (x == y) {
  } else {
    assert acc(x) &*& x != y &*& lseg(x.next, y) &*& lseg(y, z);
    lemma(x.next, y, z);
  }
}  

procedure test(x: Node, y: Node, z1: Node, z2: Node)
  requires x.next |-> z1 &*& lseg(y, null);
  ensures x.next |-> z2 &*& lseg(y, null);
{
  x.next := z2;
  var X: Set<Node>;
  assume acc(X);
  assert lseg(y, null) -** acc(X);
  assume false;
} 

procedure lemma2(x: Node, y: Node, z: Node)
  requires lseg(x, y) &*& y.next |-> z &*& lseg(z, null)
  ensures lseg(x, z) &*& lseg(z, null)
{
  if (x == y) {
    assert acc(y) &*& lseg(y.next, z) &*& y != z &*& lseg(z, null);
    assume acc(y) &*& lseg(y.next, z) &*& y != z &*& lseg(z, null);
  } else {
    lemma2(x.next, y, z);
  }
}

procedure lemma3(x: Node, y: Node, z: Node)
  requires exists X: Set<Node> :: (lseg(x, y) &*& acc(y)) && acc(X) &*& y.next == z &*& z !in X
  ensures lseg(x, z)
{
  if (x == y) {
    assert acc(y) &*& lseg(y.next, z) &*& y != z;
  } else {
    lemma3(x.next, y, z);
  }
}

procedure traverse(x: Node)
  requires lseg(x, null)
  ensures lseg(x, null)
{
  assert lseg(x, null);
  var y := x;

  while (y != null)
    invariant lseg(x, y) &*& lseg(y, null)
  {
    //assert lseg(x, y) &*& acc(y) &*& lseg(y.next, null);
    //assert lseg(x, y) &*& lseg(y, y.next) &*& lseg(y.next, null);
    //lemma(x, y, y.next);
    y := y.next;
    lemma3(x, y, null);
  }
}

procedure test_frame(x: Node, y: Node, z1: Node, z2: Node)
  requires x.next |-> z1 &*& lseg(y, null)
  ensures x.next |-> z2 &*& lseg(y, null)
{
  x.next := z2;
}

procedure copy(lst: Node) returns (res: Node)
  requires lseg(lst, null)
  ensures lseg(lst, null) &*& lseg(res, null)
{
  var curr, cp: Node := lst, null;
  while (curr != null) 
    invariant lseg(lst, curr) &*& lseg(curr, null)
    invariant lseg(cp, null)
  {
    lemma3(lst, curr, curr.next);
    var old_cp := cp;
    cp := new Node;
    cp.next := old_cp;
    curr := curr.next;
  }
  return cp;
}

procedure reverse(lst: Node) 
  returns (rev: Node)
  requires lseg(lst, null)
  ensures lseg(rev, null)
{
  rev := null;
  var curr := lst;
  while (curr != null) 
    invariant lseg(rev, null)
    invariant lseg(curr, null)
  {
    var tmp := curr;
    curr := curr.next;
    tmp.next := rev;
    rev := tmp;
  }
}

procedure filter(x: Node) returns (res: Node)
  requires lseg(x, null)
  ensures lseg(res, null)
{
  var prv: Node, curr := null, x;
  res := x;
  while (curr != null) 
    invariant (prv.next |-> curr &*& lseg(res, prv) || prv == null &*& res == curr) &*& lseg(curr, null);
  {
    var old_curr := curr;
    curr := curr.next; 
    var nondet: Bool;
    if (nondet) {
      if (prv != null) {
        prv.next := old_curr.next;
      } else {
        res := old_curr.next;
      }
      free old_curr;
    } else {
      prv := old_curr;
    }
  }
}

