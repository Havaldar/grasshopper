struct Node {
  var next: Node;
}

predicate lseg_set(x: Node, y: Node, X: set<Node>) {
  x == y && X == set<Node>() ||
  x != y &*& x in X &*& acc(x) &*& lseg_set(x.next, y, X -- set(x))
}

function root(x: Node, implicit ghost X: set<Node) returns (res: Loc) 
  requires lseg_set(x, null, X);
  requires x != null;
  ensures res.next == null && res in X;
{
  if (x.next == null) { 
    return x;
  } else {
    return root(x.next);
  }
}

procedure find(x: Node, implicit ghost X: set<Node>) 
returns (res: Node)
  requires lseg_set(x, null, X);
  ensures acc(X);
  ensures (forall z in X -- res :: z.next == res);
  ensures res.next == null &*& res == root(x);
{
  var n: Node;
  n := x.next;
  if (n != null) {
    res := find(n, root_x);
    x.next := res;
  } else {
    res := x;
  }
}

procedure union(x: Node, y: Node, 
                implicit ghost X: set<Node>, implicit ghost Y: set<Node>)
  requires lseg_set(x, null, X) &+& lseg_set(y, null, Y);
  ensures acc(X) &+& acc(Y);
  ensures forall z in X -- Y -- root(x) :: z.next == root(x);
  ensures forall z in Y -- root(y) :: z.next == root(y);
  ensures root(y).next == null;
  ensures root(x) == root(y) || root(x).next == root(y);
{
  var t: Node;
  var s: Node;
  t := find(x);
  s := find(y);
  if (t != s) {
    t.next := s;
  }
}
