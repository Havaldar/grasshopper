struct Node {
  var next: Node;
}

predicate lseg_set(x: Node, y: Node, X: Set<Node>) {
  x == y && X == Set<Node>() ||
  x != y &*& x in X &*& acc(x) &*& lseg_set(x.next, y, X -- Set(x))
}

function rep(x: Node, implicit ghost X: Set<Node) returns (res: Loc) 
  requires lseg_set(x, null, X);
  requires x != null;
  ensures res.next == null && res in X;
{
  if (x.next == null) { 
    return x;
  } else {
    return rep(x.next);
  }
}

procedure find(x: Node, implicit ghost X: Set<Node>) 
returns (res: Node)
  requires lseg_set(x, null, X);
  ensures acc(X);
  ensures (forall z in X -- res :: z.next == res);
  ensures res.next == null &*& res == rep(x);
{
  var n: Node;
  n := x.next;
  if (n != null) {
    res := find(n);
    x.next := res;
  } else {
    res := x;
  }
}

procedure union(x: Node, y: Node, 
                implicit ghost X: Set<Node>, implicit ghost Y: Set<Node>)
  requires lseg_set(x, null, X) &+& lseg_set(y, null, Y);
  ensures acc(X) &+& acc(Y);
  ensures forall z in X -- Y -- rep(x) :: z.next == rep(x);
  ensures forall z in Y -- rep(y) :: z.next == rep(y);
  ensures rep(y).next == null;
  ensures rep(x) == rep(y) || rep(x).next == rep(y);
{
  var t: Node;
  var s: Node;
  t := find(x);
  s := find(y);
  if (t != s) {
    t.next := s;
  }
}
