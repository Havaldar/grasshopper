predicate arrayseg(a: Array<Node>, i: Int, j: Int)
  requires acc(a)
{
  0 <= i && i <= j && j <= a.length &*&
  acc({ c: ArrayCell<Node> :: i <= c.index && c.index < j && c.array == a })
}

predicate array(a: Array<Node>) {
  acc(a) &*&
  arrayseg(a, 0, a.length)
}


function node_witness(x: Node, a: Array<Node>, m: Map<ArrayCell<Node>, Node>)
  returns (c: ArrayCell<Node>)

function array_state() returns (m: Map<ArrayCell<Node>, Node>)
  ensures (forall c: ArrayCell<Node> :: c.m == c[] @(matching c yields c.m));

predicate arrayseg_content(a: Array<Node>, FP0: Set<ArrayCell<Node>>)
  requires acc(a) &*& acc(FP0)
{
  /// FIXME
  (forall c: ArrayCell<Node> :: c in FP0 ==> c == node_witness(c[], a, array_state())) &&
  (forall x in FP1 :: x == node_witness(x, a, array_state())[]
   @(matching x yields node_witness(x, a, array_state())[])) &&
  (forall c: ArrayCell<Node> :: c in FP0 ==> c[] in FP1) &&
  (forall x in FP1 :: node_witness(x, a, array_state()) in FP0)
}

predicate arrayseg_with_content(a: Array<Node>, lo: Int, hi: Int)
  requires acc(a)
{
  exists X: Set<ArrayCell<Node>> ::
    arrayseg(a, lo, hi) && acc(FP0) &*&
    arrayseg_content(a, FP0)
}

predicate array_with_content(a: Array<Node>) {
  acc(a) &*&
  arrayseg_with_content(a, 0, a.length)
}


