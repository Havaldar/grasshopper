// structure and predicate declarations for set implementation 
// based on sorted singly-linked lists

include "slslist.spl";

function witness(v: Int, C: Set<Int>) returns (res: Loc<Node>) {
  true
}

function content(FP: Set<Loc<Node>>) returns (C: Set<Int>) {
  (forall x: Loc<Node> :: x in FP ==> x == witness(x.data, C)) &&
  (forall x: Loc<Node> :: x in FP ==> x.data in C) &&
  (forall v in C :: witness(v, C) in FP) &&
  (forall v: Int :: v !in C ==> witness(v, C) == null) &&
  (forall v in C :: v == witness(v, C).data @(matching v yields witness(v, C).data))
}

predicate list_set(x: Node, y: Node, C: Set<Int>, FP: Set<Loc<Node>>) {
  lseg(x, y, FP) &&
  lseg_strictly_increasing(x, FP) &&
  C == content(FP)
}
