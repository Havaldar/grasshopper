
struct Data { }

struct Node {
  var next: Node;
  var data: Data;
}

axiom forall a: Data :: !lt(a, a);
axiom forall a: Data, b: Data :: !lt(a, b) || !lt(b, a);
axiom forall a: Data, b: Data :: lt(a, b) || lt(b, a) || a == b;
axiom forall a: Data, b: Data, c: Data :: lt(a, b) && lt(b, c) ==> lt(a, c);

predicate lt(x: Data, y: Data)

predicate lseg(x: Node, y: Node) {
  acc({ z: Node :: Btwn(next, x, z, y) && z != y}) &*& Reach(next, x, y)
}

predicate lseg_strictly_increasing(x: Node, FP: Set<Node>)
  requires acc(FP)
{
  forall y: Node, z: Node :: y in FP && z in FP && Btwn(next,x,y,z) ==> lt(y.data, z.data) || y == z
}

function data_witness(v: Data, d: Map<Node, Data>, FP: Set<Node>) returns (res: Node) 

function content(FP: Set<Node>, d: Map<Node, Data>) returns (C: Set<Data>)

axiom forall FP: Set<Node>, d: Map<Node, Data>, x in FP :: x == data_witness(x.d, d, FP);

axiom forall FP: Set<Node>, d: Map<Node, Data>, x in FP :: x.d in content(FP, d);

axiom forall FP: Set<Node>, d: Map<Node, Data>, v in content(FP, d) :: data_witness(v, d, FP) in FP;

axiom forall FP: Set<Node>, d: Map<Node, Data>, v: Data :: v !in content(FP, d) ==> data_witness(v, d, FP) == null;

axiom forall FP: Set<Node>, d: Map<Node, Data>, v in content(FP, d) :: v == data_witness(v, d, FP).d
  @(matching v, content(FP, d) yields data_witness(v, d, FP).d);


predicate list_set(x: Node, y: Node, C: Set<Data>) {
  exists X: Set<Node> :: lseg(x, y) && acc(X) &*&
    lseg_strictly_increasing(x, X) &&
    C == content(X, data)
}


procedure append(val: Data, x: Node, implicit ghost C: Set<Data>) 
  returns (res: Node)
  requires list_set(x, null, C)
  requires forall v in C :: lt(val, v)
  ensures list_set(res, null, C ++ Set(val))
{
  res := new Node;
  res.next := x;
  res.data := val;
}

procedure insert(lst: Node, val: Data, implicit ghost C: Set<Data>)
  returns (res: Node)
  requires list_set(lst, null, C)
  ensures list_set(res, null, C ++ Set(val))
{
  var curr: Node;
  curr := lst;
  var prev: Node;
  prev := null;
  
  while (curr != null && lt(curr.data, val))
    invariant (prev == null && curr == lst || lt(prev.data, val) &*& prev.next |-> curr) -** 
      list_set(lst, null, C)
  {
    prev := curr;
    curr := curr.next;
  }
  
  if (curr != null && curr.data == val) {
    return lst;
  }
  
  var n: Node;
  n := append(val, curr);
  
  if (prev == null) {
    return n;
  } else {
    prev.next := n;
    return lst;
  }
}

