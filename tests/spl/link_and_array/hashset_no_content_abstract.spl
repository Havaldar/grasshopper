include "../array/node_array.spl";

struct Node {
  var next: Node;
  var data: Int;
}

 
function lseg_footprint(m: Map<Node, Node>, x: Node, y: Node) returns (FP: Set<Node>)

function fp_witness(x: Node, m: Map<ArrayCell<Node>, Node>) returns (c: ArrayCell<Node>)
  
predicate lseg(m: Map<Node, Node>, x: Node, y: Node)(FP: Set<Node>) {
  FP == lseg_footprint(m, x, y)
}
  
struct HashSet {
  var size: Int; /* the size of the set */
  var buckets: Array<Node>; /* the set elements */
}

function arrayseg_buckets_footprint(a: Array<Node>, FP0: Set<ArrayCell<Node>>)
  returns (FP1: Set<Node>)
{
  (forall c in FP0, x: Node :: x in lseg_footprint(next, c.array[c.index], null) ==> x in FP1) &&
  (forall x in FP1 :: fp_witness(x, array_state()) in FP0) &&
  (forall x in FP1 :: x in lseg_footprint(next, fp_witness(x, array_state()).array[fp_witness(x, array_state()).index], null)
   @(matching x yields lseg_footprint(next, fp_witness(x, array_state()).array[fp_witness(x, array_state()).index], null))) &&
  (forall c in FP0, x: Node :: x in lseg_footprint(next, c.array[c.index], null) ==> fp_witness(x, array_state()) == c)
  //all nodes reachable from the head of the bucket are in the footprint
  //(forall c: ArrayCell<Node>, x: Node :: c in FP0 && Reach(next, c.array[c.index], x) ==> x in FP1 || x == null) &&
  //all nodes in the footprint are reachable from the bucket head
  //(forall x in FP1 :: Reach(next, a[hash(a.length, x.data)], x) && x != null
     // @(matching x yields a[hash(a.length, x.data)])) &&
  // the bucket heads are in the array's footprint
  //(forall x in FP1 :: a.cells[hash(a.length, x.data)] in FP0
     //@(matching x yields a.cells[hash(a.length, x.data)] ))
}

predicate arrayseg_with_buckets(a: Array<Node>, lo: Int, hi: Int)
  (FP0: Set<ArrayCell<Node>>, FP1: Set<Node>)
{
  0 <= lo && lo <= hi && hi <= a.length &&
  FP0 == arrayseg_footprint(a, lo, hi) &&
  FP1 == arrayseg_buckets_footprint(a, FP0) &&
  (forall c in FP0 :: lseg(next, c.array[c.index], null, lseg_footprint(next, c.array[c.index], null)))
  //all the elts from a list have the same hash, and this is the index in the array
  //(forall v in FP1 :: Btwn(next, a[hash(a.length, v.data)], v, null) @(matching v yields a[hash(a.length, v.data)]))
}

predicate array_with_buckets(a: Array<Node>)
  (FP0: Set<Array<Node>>, FP1: Set<ArrayCell<Node>>, FP2: Set<Node>)
{
  FP0 == Set(a) &&
  arrayseg_with_buckets(a, 0, a.length, FP1, FP2)
}

// some ghost function that we can use for the spec of hash
function hash(max: Int, value: Int)
  returns (res: Int)
{
  res >= 0 && res < max
}

predicate hset(h: HashSet)
  (FP0: Set<HashSet>, FP1: Set<Array<Node>>,
   FP2: Set<ArrayCell<Node>>, FP3: Set<Node>)
{
  h.size == h.buckets.length &&
  FP0 == Set(h) &&
  array_with_buckets(h.buckets, FP1, FP2, FP3) &&
  true
}


procedure insert(lst: Node, val: Int) 
  returns (res: Node)
  requires lseg(next, lst, null)
  ensures lseg(next, res, null)

procedure hashset_add(hashset: HashSet, value: Int)
  requires hset(hashset)
  ensures hset(hashset)
{
  var hashval := hash(hashset.size, value);
  //assert hset(hashset);
  var list := hashset.buckets[hashval];
  //assert lseg(list, null) -** hset(hashset);
  hashset.buckets[hashval] := insert(list, value);
}

procedure contains(lst: Node, value: Int) 
  returns (res: Bool)
  requires lseg(next, lst, null)
  ensures lseg(next, lst, null)
{
  
}
  
procedure hashset_member(hashset: HashSet, value: Int)
  returns (res: Bool)
  requires hset(hashset)
  ensures hset(hashset)
{
  var hashval := hash(hashset.size, value);
  var list := hashset.buckets[hashval];
  return contains(list, value);
}

procedure delete(lst: Node, value: Int) 
  returns (res: Node)
  requires lseg(next, lst, null)
  ensures lseg(next, res, null)

procedure hashset_remove(hashset: HashSet, value: Int)
  requires hset(hashset)
  ensures hset(hashset)
{
  var hashval := hash(hashset.size, value);
  var list := hashset.buckets[hashval];
  hashset.buckets[hashval] := delete(list, value);
}


