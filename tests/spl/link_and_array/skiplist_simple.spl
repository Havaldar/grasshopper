// Let's assume all next arrays are of the same height - to make calculating footprint easier. In practice, each node has a different height, and array cells beyond this height can have arbitrary data.

struct SkipList {
  var max_height: Int;
  var height: Int;
  var head: Node;
}

struct Node {
  var data: Int;
  var next: Array<Node>;
}

function next_map(h: Int) returns (m: Map<Node, Node>) {
  // This is syntactically incorrect:
  // m == next[h]
  // As is this:
  forall x: Node, y: Node, z: Node :: Btwn(next[h], x, y, z) == Btwn(m, x, y, z)
}

function lseg_footprint(x: Node, y: Node, h: Int) returns (FP: Set<Node>) {
  forall z: Node :: z in FP == (Btwn(next_map(h), x, z, y) && z != y)
}

predicate lseg(x: Node, y: Node, h: Int)(FP: Set<Node>) {
  Btwn(next_map(h), x, y, y) && FP == lseg_footprint(x, y, h)
}

predicate lseg_increasing(x: Node, h: Int, FP: Set<Node>) {
  forall y: Node, z: Node :: y in FP && z in FP && Btwn(next_map(h),x,y,z) ==> y.data <= z.data
}

predicate slseg(x: Node, y: Node, h: Int)(FP: Set<Node>) {
  lseg(x, y, h, FP) &&
  lseg_increasing(x, h, FP)
}

function arrayOwner(a: Array<Node>, FP: Set<Node>) returns (x: Node) { true }

function array_footprint(x: Node, y: Node, FP1: Set<Node>) returns (FP2: Set<Array<Node>>) {
  // One way
  forall z: Node :: (Btwn(next_map(0), x, z, y) && z != y)
    ==>
    (z.next in FP2) &&
  // Return
  (forall a: Array<Node>:: a in FP2 ==> arrayOwner(a, FP1) in FP1 && arrayOwner(a, FP1).next == a) &&
  (forall a: Array<Node>:: a !in FP2 ==> arrayOwner(a, FP1) == null) &&
  // disjointness constraints
  (forall a: Node, b: Node:: a in FP1 && b in FP1 && a != b ==> a.next != b.next)
}

function array_cell_footprint(x: Node, y: Node, FP2: Set<Array<Node>>) returns (FP3: Set<ArrayCell<Node>>) {
  // One way
  forall z: Node :: (Btwn(next_map(0), x, z, y) && z != y)
    ==>
     (forall i: Int :: 0 <= i && i < z.next.length ==> z.next.cells[i] in FP3) &&
  // Return
  (forall c: ArrayCell<Node>:: c in FP3 ==> c.array in FP2 && c.index >= 0 && c.index < c.array.length)
}

predicate skiplist(l: SkipList)(FP0: Set<SkipList>, FP1: Set<Node>, FP2: Set<Array<Node>>, FP3: Set<ArrayCell<Node>>) {
  0 <= l.height && l.height < l.max_height &&
  FP0 == Set<Loc<SkipList>>(l) &&
  slseg(l.head, null, 0, FP1) &&
    array_footprint(l.head, null, FP1) == FP2 &&
    array_cell_footprint(l.head, null, FP2) == FP3
}

procedure trivial_add(this: SkipList, x: Int)
  returns (res: Bool)
  requires skiplist(this)
  ensures skiplist(this)
{
  if (this.head.data > x) {
    // Insert into the beginning:
    var w: Node := new Node;
    w.data := x;
    w.next := new Array<Node>(1);
    w.next[0] := this.head;
    this.head := w;
  }
  var u: Node := this.head;

  while (u.next[0] != null && u.next[0].data < x)
    invariant skiplist(this)
    invariant u.data <= x
  {
    u := u.next[0];
  }
  var w: Node := new Node;
  w.data := x;
  w.next := new Array<Node>(1);

  w.next[0] := u.next[0];
  u.next[0] := w;
}
