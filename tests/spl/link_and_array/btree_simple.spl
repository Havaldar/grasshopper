//  inspired by
//  http://opendatastructures.org/ods-java/14_2_B_Trees.html
//  under CC-BY
//  full source at http://opendatastructures.org/ods-java.tgz

struct Node {
  var keys: Array<Int>; /** The keys stored in this block */
  var children: Array<Node>; /** The indicies of the children of this block (if any) */
  /* NOTE: adding these two */
  var num_keys: Int;
  var ghost parent: Node;
}

struct BTree {
  var B: Int;
  var root: Node;
}

/* -------------------- Predicate Definitions -------------------- */

function int_arrayseg_fp(a: Array<Int>, i: Int, j: Int)
  returns (FP: Set<ArrayCell<Int>>)
{
  (forall c: ArrayCell<Int> ::
     c in FP == (i <= c.index && c.index < j && c.array == a))
}

predicate int_arrayseg(a: Array<Int>, i: Int, j: Int)(FP: Set<ArrayCell<Int>>) {
  0 <= i && i <= j && j <= a.length &&
  FP == int_arrayseg_fp(a, i, j)
}

predicate sorted_int_arrayseg(a: Array<Int>, i: Int, j: Int)(FP: Set<ArrayCell<Int>>) {
  0 <= i && i <= j && j <= a.length &&
  FP == int_arrayseg_fp(a, i, j) &&
  (forall k: Int, l: Int:: k >= i && k <= l && l < j ==> a[k] <= a[l])
}

function node_arrayseg_fp(a: Array<Node>, i: Int, j: Int)
  returns (FP: Set<ArrayCell<Node>>)
{
  (forall c: ArrayCell<Node> ::
     c in FP == (i <= c.index && c.index < j && c.array == a))
}

predicate node_arrayseg(a: Array<Node>, i: Int, j: Int)(FP: Set<ArrayCell<Node>>) {
  0 <= i && i <= j && j <= a.length &&
  FP == node_arrayseg_fp(a, i, j)
}

predicate node_arraysegWithNode(a: Array<Node>, lo: Int, hi: Int)( FP0: Set<ArrayCell<Node>>, FP1: Set<Node>) {
  0 <= lo && lo <= hi && hi <= a.length &&
  FP0 == node_arrayseg_fp(a, lo, hi) &&
  (forall c: ArrayCell<Node>:: c in FP0 == a[c.index] in FP1) &&
  (forall c: ArrayCell<Node>, d: ArrayCell<Node>:: c in FP0 && d in FP0 ==> a[c.index] != a[d.index])
}

function node_footprint(r: Node) returns (FP: Set<Node>) {
  forall x: Node :: x in FP == (Btwn(parent, x, r, r) && r != null)
}

function array_int_owner(a: Array<Int>, FP_N: Set<Node>) returns (n: Node)

function array_int_fp(FP_N: Set<Node>) returns (FP_A_I: Set<Array<Int>>) {
  (forall n: Node :: n in FP_N ==> n.keys in FP_A_I) &&
  (forall a: Array<Int> :: a in FP_A_I ==> array_int_owner(a, FP_N) in FP_N && array_int_owner(a, FP_N).keys == a)
}

function array_node_owner(a: Array<Node>, FP_N: Set<Node>) returns (n: Node)

function array_node_fp(FP_N: Set<Node>) returns (FP_A_N: Set<Array<Node>>) {
  (forall n: Node :: n in FP_N ==> n.children in FP_A_N) &&
  (forall a: Array<Node> :: a in FP_A_N ==> array_node_owner(a, FP_N) in FP_N && array_node_owner(a, FP_N).children == a)
}

function arraycell_int_fp(FP_A_I: Set<Array<Int>>) returns (FP_AC_I: Set<ArrayCell<Int>>) {
  (forall a: Array<Int>, ac: ArrayCell<Int> :: a in FP_A_I && ac in int_arrayseg_fp(a, 0, a.length) ==> ac in FP_AC_I) &&
  (forall ac: ArrayCell<Int> :: ac in FP_AC_I ==> ac.array in FP_A_I)
}

function arraycell_node_fp(FP_A_N: Set<Array<Node>>) returns (FP_AC_N: Set<ArrayCell<Node>>) {
  (forall a: Array<Node>, ac: ArrayCell<Node> :: a in FP_A_N && ac in node_arrayseg_fp(a, 0, a.length) ==> ac in FP_AC_N) &&
  (forall ac: ArrayCell<Node> :: ac in FP_AC_N ==> ac.array in FP_A_N)
}

predicate btree(b: BTree)(FP_B: Set<BTree>, FP_N: Set<Node>, FP_A_I: Set<Array<Int>>, FP_AC_I: Set<ArrayCell<Int>>, FP_A_N: Set<Array<Node>>, FP_AC_N: Set<ArrayCell<Node>>) {
  FP_B == Set(b) &&
  FP_N == node_footprint(b.root) &&
  FP_A_I == array_int_fp(FP_N) &&
  FP_AC_I == arraycell_int_fp(FP_A_I) &&
  FP_A_N == array_node_fp(FP_N) &&
  FP_AC_N == arraycell_node_fp(FP_A_N) &&

  /* The order, B, is at least 2 */
  b.B >= 2 &&
  /* keys and children arrays are of size 2B */
  (forall n: Node :: n in FP_N ==> n.children.length == 2 * b.B && n.keys.length == 2 * b.B) &&
  /* num_keys is at least (root ? 1 : B - 1) */
  (forall n: Node :: n in FP_N ==> (n == b.root && 2 <= n.num_keys || b.B - 1 <= n.num_keys) && n.num_keys <= n.keys.length) &&
  /* children[] has num_keys + 1 non-null elements */
  (forall n: Node, i: Int :: n in FP_N && 0 <= i && i < n.children.length ==>
   (i <= n.num_keys && n.children[i] != null) || (i > n.num_keys && n.children[i] == null)
   ) &&
  /* The keys of every node are sorted */
  (forall n: Node :: n in FP_N ==> sorted_int_arrayseg(n.keys, 0, n.keys.length, int_arrayseg_fp(n.keys, 0, n.keys.length))) &&
  true
}

/* -------------------- Actual Implementation -------------------- */

procedure find(b: BTree, x: Int) returns (res: Node)
  requires btree(b)
  ensures btree(b)
{
  var n := b.root;
  var z: Node := null;
  var flag := false;
  while (n != null && !flag)
    invariant btree(b)
  {
    var i: Int := findIt(n.keys, x, 0, n.keys.length);
    if (n.keys[i] == x)
      flag := true;
    if (n.keys[i] != n.num_keys)
      z := n.children[i];
    n := n.children[i];
  }
  return z;
}

/* For simplicity, replaced this with array/bsearch.spl */
procedure findIt(a: Array<Int>, x: Int, begin: Int, end: Int) returns (idx: Int)
  requires int_arrayseg(a, begin, end)
  requires forall i: Int, j: Int :: begin <= i && i < j && j < end ==> a[i] <= a[j]
  requires 0 <= begin && begin < end && end <= a.length
  ensures int_arrayseg(a, begin, end)
  ensures begin <= idx && (idx < end && a[idx] >= x && (idx > begin ==> a[idx-1] < x)) || (idx == end && a[idx-1] < x)
{
  var lo := begin;
  var hi := end;

  while (hi > lo)
    invariant int_arrayseg(a, begin, end)
    invariant forall i: Int, j: Int :: begin <= i && i < j && j < end ==> a[i] <= a[j]
    invariant begin <= lo && lo <= hi && hi <= end
    invariant (lo < end && (a[lo] < x || (a[lo] >= x && (lo > begin ==> a[lo-1] < x)))) || (lo == end && a[lo-1] < x)
    invariant hi == end || a[hi] >= x
  {
    var mid := (lo + hi) / 2;
    if (a[mid] < x)
    {
      lo := mid + 1;
    }
    else
    {
      hi := mid;
    }
  }
  return lo;
}
