struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate tree(x: Node, y: Node) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    tree(x.left, x) &*&
    tree(x.right, x)
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure union(h1: Node, h2: Node)
    returns (res: Node)
    requires tree(h1, null) &*& tree(h2, null);
    requires treeAllocInvariant(Alloc);
    ensures treeAllocInvariant(Alloc);
    ensures tree(res, null);
{
    if (h1 == null) {
        return h2;
    } else if (h2 == null) {
        return h1;
    } else if (h1.data <= h2.data) {
        var u: Node, r: Node;
        r := h1.right;
        h1.right := h1.left;
        if (r != null) { r.parent := null; }
        u := union(h2, r);
        h1.left := u;
        if (u != null) { u.parent := h1; }
        return h1;
    } else {
        return union(h2, h1);
    }
}

procedure insert(h: Node, value: int) returns (res: Node)
    requires tree(h, null);
    requires treeAllocInvariant(Alloc);
    ensures treeAllocInvariant(Alloc);
    ensures tree(res, null);
{
    var n: Node;
    n := new Node;
    n.left := null;
    n.right := null;
    n.parent := null;
    n.data := value;
    return union(h, n);
}

procedure extractMin(h: Node) returns (min: int, rest: Node)
    requires tree(h, null) &*& h != null;
    requires treeAllocInvariant(Alloc);
    ensures treeAllocInvariant(Alloc);
    ensures  tree(rest, null);
{
    var d : int;
    d := h.data;
    var hp: Node, r: Node, l: Node;
    l := h.left;
    r := h.right;
    h.left := null;
    h.right := null;
    if (l != null) { l.parent := null; }
    if (r != null) { r.parent := null; }
    hp := union(l, r);
    free h;
    return d, hp;
}
