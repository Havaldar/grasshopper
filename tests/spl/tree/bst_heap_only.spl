struct Node {
  var left: Node;
  var right: Node;
  var data: int;
}

predicate bstree_ho(x: Node) {
    x == null)
  ||
    //strucuture
    x != null &*&
    acc(x) &*&
    bstree_ho(x.left) &*&
    bstree_ho(x.right)
}

procedure create() returns (res: Node)
  ensures bstree_ho(res);
{
    return null;
}

procedure insert(tree: Node, value: int) returns (res: Node)
  requires bstree_ho(tree);
  ensures bstree_ho(res);
{
    if (tree == null) {
        var t: Node;
        t := new Node;
        t.left := null;
        t.right := null;
        t.data := value;
        return t;
    }
    if (tree.data > value) {
        tree.left := insert(tree.left, value);
    } else if (tree.data < value) {
        tree.right := insert(tree.right, value);
    }
    return tree;
}

procedure extract_max(tree: Node) returns (others: Node, max: Node)
  requires bstree_ho(tree) &*& tree != null;
  ensures  bstree_ho(others) &*& acc(max);
{
    if (tree.right != null) {
        var c, m: Node;
        c, m := extract_max(tree.right); 
        tree.right := c;
        return tree, m;
    } else {
        return tree.left, tree;
    }
}

procedure remove(tree: Node, value: int) returns (res: Node)
  requires bstree_ho(tree);
  ensures bstree_ho(res);
{
    if (tree == null) {
        return null;
    } else if (tree.data == value) {
        if (tree.left == null && tree.right == null) {
            free(tree);
            return null;
        } else if (tree.left != null && tree.right == null) {
            res := tree.left;
            free(tree);
            return res;
        } else if (tree.left == null && tree.right != null) {
            res := tree.right;
            free(tree);
            return res;
        } else {
            val l, m: Node;
            l, m := extract_max(tree.left);
            m.left := l;
            m.right := tree.right;
            free(tree);
            return m;
        }
    } else if (tree.data > value) {
        tree.left := remove(tree.left, value);
        return tree;
    } else {
        tree.right := remove(tree.right, value);
        return tree;
    }
}


procedure destroy(tree: Node)
  requires bstree_ho(tree);
  ensures emp;
{
    if (tree != null) {
        destroy(tree.left);
        destroy(tree.right);
    }
}

