struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate tree(x: Node) {
    x == null
  ||
    x != null &*&
    acc(x) &*&
    x.parent == x.parent &*&
    tree(x.left) &*&
    tree(x.right)
}

predicate stree(x: Node, content: set<int>) {
    x == null &*&
    content == set<int>()
  ||
    x != null &*&
    acc(x) &*&
    x.parent == x.parent &*&
    (exists l_content: set<int>, r_content: set<int> :: 
      (forall d in l_content :: d < x.data) &*&
      (forall d in r_content :: d > x.data) &*&
      content == l_content ++ r_content ++ set<int>(x.data) &*&
      stree(x.left, l_content) &*&
      stree(x.right, r_content))
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure contains(root: Node, val: int, implicit ghost content: set<int>)
  returns (res: bool)
  requires stree(root, content) &*& treeAllocInvariant(Alloc);
  ensures  stree(root, content) &*& treeAllocInvariant(Alloc);
  ensures  res == val in content;
{
    var cur: Node;
    cur := root;
    while(cur != null && cur.data != val)
        invariant tree(cur); //heavily rely on the unmodified field optimisation
    {
        if (cur.data > val) {
            cur := cur.left;
        } else {
            cur := cur.right;
        }
    }
    if (cur == null) {
        return false;
    } else {
        return true;
    }
}
