struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: Int;
}

predicate stree(x: Node, content: Set<Int>) {
    x == null &*&
    content == Set<Int>()
  ||
    x != null &*&
    acc(x) &*&
    x.parent == x.parent &*&
    (exists l_content: Set<Int>, r_content: Set<Int> :: 
      (forall d in l_content :: d < x.data) &*&
      (forall d in r_content :: d > x.data) &*&
      content == l_content ++ r_content ++ Set<Int>(x.data) &*&
      stree(x.left, l_content) &*&
      stree(x.right, r_content))
}

predicate treeAllocInvariant(X: Set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure contains(root: Node, val: Int, implicit ghost content: Set<Int>)
  returns (res: Bool)
  requires stree(root, content) &*& treeAllocInvariant(Alloc);
  ensures  stree(root, content) &*& treeAllocInvariant(Alloc);
  ensures  res == val in content;
{
    var curr: Node;
    curr := root;

    while (curr != null && curr.data != val) 
      invariant (exists content1: Set<Int> :: 
                   (stree(curr, content1) -** stree(root, content))
                 &*& (val in content == val in content1));
      invariant treeAllocInvariant(Alloc);
      invariant treeAllocInvariant(Alloc);
    {
        if (curr.data < val) {
          curr := curr.left;
        } else if (curr.data > val) {
          curr := curr.right;
        }
    }

    if (curr != null) return true;
    else return false;
}
