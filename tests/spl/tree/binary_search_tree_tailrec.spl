struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: Int;
}

predicate stree(x: Node, content: Set<Int>) {
    x == null &*&
    content == Set<Int>()
  ||
    x != null &*&
    acc(x) &*&
    x.parent == x.parent &*&
    (exists l_content: Set<Int>, r_content: Set<Int> :: 
      (forall d in l_content :: d < x.data) &*&
      (forall d in r_content :: d > x.data) &*&
      content == l_content ++ r_content ++ Set<Int>(x.data) &*&
      stree(x.left, l_content) &*&
      stree(x.right, r_content))
}

predicate tree(x: Node) {
  x == null
  ||
  x != null &*&
  x.parent |-> x.parent &*&
  tree(x.left) &*&
  tree(x.right)
}

procedure contains(root: Node, val: Int, implicit ghost content: Set<Int>)
  returns (res: Bool)
  requires stree(root, content);
  ensures  stree(root, content);
  ensures  res == val in content;
{
  var curr: Node;
  curr := root;

  while (curr != null && curr.data != val) 
    invariant (exists content1: Set<Int> :: 
                (stree(curr, content1) -** stree(root, content))
                &*& (val in content == val in content1));
  {
    if (curr.data > val) {
      curr := curr.left;
    } else if (curr.data < val) {
      curr := curr.right;
    }
  }

  if (curr != null) return true;
  else return false;
}

procedure singleton(val: Int)
  returns (root: Node)
  requires emp;
  ensures stree(root, Set<Int>(val)) &*& root.parent == null;
{
  root := new Node;
  root.left := null;
  root.right := null;
  root.parent := null;
  root.data := val;
}

procedure insert(root: Node, val: Int, implicit ghost Content: Set<Int>)
  returns (nroot: Node)
  requires stree(root, Content);
  ensures stree(nroot, Content ++ Set<Int>(val));
{
  if (root == null) {
    nroot := singleton(val);
    return nroot;
  }

  var curr: Node;
  curr := root;

  while (curr.data > val && curr.left != null ||
         curr.data < val && curr.right != null) 
    invariant exists Content1: Set<Int> :: 
      (acc(curr) -** stree(curr, Content1) -** stree(root, Content));
    invariant forall x: Node :: Btwn(parent, curr, x.left, x) &&
      Btwn(parent, x, root, root) ==> x.data > val; 
    invariant forall x: Node :: Btwn(parent, curr, x.right, x) &&
      Btwn(parent, x, root, root) ==> x.data < val; 
  {
    if (curr.data > val && curr.left != null) {
      curr := curr.left;
    } else if (curr.data < val && curr.right != null) {
      curr := curr.right;
    }
  }

  if (curr.data == val) {
    return root;
  } else {
    var n: Node;
    n := singleton(val);
    n.parent := curr;
    if (curr.data > val) {
      curr.left := n;
      return root;
    } else {
      curr.right := n;
      return root;
    }
  }
}

predicate treeAllocInvariant(X: Set<Node>) {
  (forall n in X :: n.parent == n.parent)
}
