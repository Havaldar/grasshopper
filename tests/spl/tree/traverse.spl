struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate bstree(x: Node, y: Node, lb: int, ub: int) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    lb <= x.data &*&
    x.data <= ub &*&
    bstree(x.left, x, lb, x.data) &*&
    bstree(x.right, x, x.data, ub)
}

predicate tree(x: Node, y: Node) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    tree(x.left, x) &*&
    tree(x.right, x)
}

predicate bheap(x: Node, y: Node, ub: int) {
    x == null
  ||
    x != null &*&
    x.data <= ub &*&
    x.parent |-> y &*&
    bheap(x.left, x, ub) &*&
    bheap(x.right, x, ub) &*&
    (x.left == null || (x.left != null && x.left.data <= x.data)) &*&
    (x.right == null || (x.right != null && x.right.data <= x.data)) 
}

predicate heap(x: Node, y: Node) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    heap(x.left, x) &*&
    heap(x.right, x) &*&
    (x.left == null || (x.left != null && x.left.data <= x.data)) &*&
    (x.right == null || (x.right != null && x.right.data <= x.data)) 
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

//1m50
procedure traverse1(root: Node, p: Node) 
  requires tree(root, p);
  requires treeAllocInvariant(Alloc);
  ensures  treeAllocInvariant(Alloc);
  ensures  tree(root, p);
{
  if (root != null) {
    traverse1(root.left, root);
    traverse1(root.right, root);
  }
}

//1m50
procedure traverse2(root: Node, p: Node, ghost lb: int, ghost ub: int) 
  requires bstree(root, p, lb, ub);
  requires treeAllocInvariant(Alloc);
  ensures  treeAllocInvariant(Alloc);
  ensures  bstree(root, p, lb, ub);
{
  if (root != null) {
    traverse2(root.left, root, lb, root.data - 1);
    traverse2(root.right, root, root.data + 1, ub);
  }
}

//5 min
procedure traverse3(root: Node, p: Node, ghost ub: int) 
  requires bheap(root, p, ub);
  requires treeAllocInvariant(Alloc);
  ensures  treeAllocInvariant(Alloc);
  ensures  bheap(root, p, ub);
{
  if (root != null) {
    traverse3(root.left, root, root.data);
    traverse3(root.right, root, root.data);
  }
}

//34 min
procedure traverse4(root: Node, p: Node, ghost ub: int) 
  requires heap(root, p);
  requires root == null || root.data <= ub;
  requires treeAllocInvariant(Alloc);
  ensures  treeAllocInvariant(Alloc);
  ensures  heap(root, p);
  ensures  root == null || root.data <= ub;
{
  if (root != null) {
    traverse3(root.left, root, root.data);
    traverse3(root.right, root, root.data);
  }
}
