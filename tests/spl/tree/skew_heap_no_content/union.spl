struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate heap(x: Node, y: Node) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    heap(x.left, x) &*&
    heap(x.right, x) &*&
    (x.left == null || (x.left != null && x.left.data <= x.data)) &*&
    (x.right == null || (x.right != null && x.right.data <= x.data)) 
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure union(h1: Node, h2: Node)
    returns (res: Node)
    requires heap(h1, null) &*& heap(h2, null);
    requires treeAllocInvariant(Alloc);
    ensures treeAllocInvariant(Alloc);
    ensures heap(res, null);
{
    if (h1 == null) {
        return h2;
    } else if (h2 == null) {
        return h1;
    } else if (h1.data >= h2.data) {
        var u: Node, r: Node;
        r := h1.right;
        h1.right := h1.left;
        if (r != null) { r.parent := null; }
        u := union(h2, r);
        h1.left := u;
        if (u != null) { u.parent := h1; }
        return h1;
    } else {
        return union(h2, h1);
    }
}
