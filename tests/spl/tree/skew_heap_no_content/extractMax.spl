struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate heap(x: Node, y: Node) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    heap(x.left, x) &*&
    heap(x.right, x) &*&
    (x.left == null || (x.left != null && x.left.data <= x.data)) &*&
    (x.right == null || (x.right != null && x.right.data <= x.data)) 
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure union(h1: Node, h2: Node)
    returns (res: Node)
    requires heap(h1, null) &*& heap(h2, null);
    requires treeAllocInvariant(Alloc);
    ensures treeAllocInvariant(Alloc);
    ensures heap(res, null);


procedure extractMax(h: Node) returns (min: int, rest: Node)
    requires heap(h, null) &*& h != null;
    requires treeAllocInvariant(Alloc);
    ensures treeAllocInvariant(Alloc);
    ensures  heap(rest, null);
{
    var d : int;
    d := h.data;
    var hp: Node, r: Node, l: Node;
    l := h.left;
    r := h.right;
    h.left := null;
    h.right := null;
    if (l != null) { l.parent := null; }
    if (r != null) { r.parent := null; }
    hp := union(l, r);
    free h;
    return d, hp;
}
