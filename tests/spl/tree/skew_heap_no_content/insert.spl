struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate heap(x: Node, y: Node) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    heap(x.left, x) &*&
    heap(x.right, x) &*&
    (x.left == null || (x.left != null && x.left.data <= x.data)) &*&
    (x.right == null || (x.right != null && x.right.data <= x.data)) 
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure union(h1: Node, h2: Node)
    returns (res: Node)
    requires heap(h1, null) &*& heap(h2, null);
    requires treeAllocInvariant(Alloc);
    ensures treeAllocInvariant(Alloc);
    ensures heap(res, null);


procedure insert(h: Node, value: int) returns (res: Node)
    requires heap(h, null);
    requires treeAllocInvariant(Alloc);
    ensures treeAllocInvariant(Alloc);
    ensures heap(res, null);
{
    var n: Node;
    n := new Node;
    n.left := null;
    n.right := null;
    n.parent := null;
    n.data := value;
    return union(h, n);
}
