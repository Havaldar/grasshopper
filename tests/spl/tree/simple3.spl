struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate tree(x: Node, y: Node) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    tree(x.left, x) &*&
    tree(x.right, x)
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure insert(root: Node, value: int, p: Node)
returns (new_root: Node)
  requires tree(root, p);
  requires treeAllocInvariant(Alloc);
  ensures tree(new_root, p);
  ensures treeAllocInvariant(Alloc);
{
  if (root == null) {
    var t: Node;
    t := new Node;
    t.left := null;
    t.right := null;
    //t.parent := p;
    t.data := value;
    return t;
  }
  if (root.data > value) {
    root.left := insert(root.left, value, root);
    return root;
  } else if (root.data < value) {
    root.right := insert(root.right, value, root);
    return root;
  }
}


procedure extract_max(root: Node, p: Node) returns (others: Node, max: Node)
  requires p in Alloc || p == null;
  requires tree(root, p) &*& root != null;
  requires treeAllocInvariant(Alloc);
  ensures  tree(others, p);
  ensures  acc(max) &*& max.left == null &*& max.right == null &*& max.parent == null;
  ensures  treeAllocInvariant(Alloc);
{
    if (root.right != null) {
        var c: Node, m: Node;
        c, m := extract_max(root.right, root); 
        root.right := c;
        return root, m;
    } else {
        var c: Node;
        c := root.left;
        root.left := null;
        root.parent := null;
        if (c != null) {
          c.parent := p;
        }
        return c, root;
    }
}

procedure destroy(root: Node)
  requires tree(root, null);
  requires treeAllocInvariant(Alloc);
  ensures emp;
  ensures treeAllocInvariant(Alloc);
{
   if (root != null) {
       var c: Node;
       
       c := root.left;
       root.left := null;
       if (c != null) {
         c.parent := null;
       }
       destroy(c);

       c := root.right;
       root.right := null;
       if (c != null) {
         c.parent := null;
       }
       destroy(c);

       free root;
   }
}
