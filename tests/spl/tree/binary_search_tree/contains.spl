struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: Int;
}

predicate bstree_cnt(x: Node, y: Node, lb: Int, ub: Int, content: Set<Int>) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    lb <= x.data &*&
    x.data <= ub &*&
    bstree_cnt(x.left, x, lb, x.data - 1, content) &*&  //TODO content
    bstree_cnt(x.right, x, x.data + 1, ub, content)     //TODO content
}

predicate treeAllocInvariant(X: Set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure contains(root: Node, val: Int, p: Node,
                   ghost lb: Int, ghost ub: Int,
                   implicit ghost content: Set<Int>)
  returns (res: Bool)
  requires bstree_cnt(root, p, lb, ub, content);
  requires treeAllocInvariant(Alloc);
  ensures  treeAllocInvariant(Alloc);
  ensures  bstree_cnt(root, p, lb, ub, content);
  ensures  res == val in content;
{
  if (root == null) {
    return false;
  } else { 
    if (val == root.data) {
      return true;
    } else if (val < root.data) {
      return contains(root.left, val, root, lb, root.data -1);
    } else {
      return contains(root.right, val, root, root.data +1, ub);
    }
  }
}
