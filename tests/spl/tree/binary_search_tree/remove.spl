struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: Int;
}

predicate bstree_cnt(x: Node, y: Node, lb: Int, ub: Int, content: Set<Int>) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    lb <= x.data &*&
    x.data <= ub &*&
    bstree_cnt(x.left, x, lb, x.data - 1, content) &*&  //TODO content
    bstree_cnt(x.right, x, x.data + 1, ub, content)     //TODO content
}

predicate treeAllocInvariant(X: Set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure extract_max(root: Node, ghost p: Node,
                      ghost lb: Int, ghost ub: Int,
                      implicit ghost content: Set<Int>)
returns (others: Node, max: Node)
  requires bstree_cnt(root, p, lb, ub, content) &*& root != null;
  requires treeAllocInvariant(Alloc);
  ensures  bstree_cnt(others, p, lb, max.data-1, content -- Set(max.data)) &*& acc(max);
  ensures  max.right == null && max.parent == null && max.data <= ub && lb <= max.data;
  ensures  treeAllocInvariant(Alloc);
{
    if (root.right != null) {
        var c: Node, m: Node;
        c, m := extract_max(root.right, root, root.data + 1, ub); 
        root.right := c;
        return root, m;
    } else {
        var c: Node;
        c := root.left;
        root.parent := null;
        if (c != null) {
          c.parent := p;
        }
        return c, root;
    }
}

procedure remove(root: Node, value: Int, p: Node,
                 ghost lb: Int, ghost ub: Int,
                 implicit ghost content: Set<Int>)
returns (res: Node)
  requires bstree_cnt(root, p, lb, ub, content);
  requires treeAllocInvariant(Alloc);
  ensures bstree_cnt(res, p, lb, ub, content -- Set(value));
  ensures treeAllocInvariant(Alloc);
{
    if (root == null) {
        return null;
    } else if (root.data == value) {
        if (root.left == null && root.right == null) {
            root.parent := null;
            free(root);
            return null;
        } else if (root.left != null && root.right == null) {
            res := root.left;
            root.parent := null;
            free(root);
            res.parent := p;
            return res;
        } else if (root.left == null && root.right != null) {
            res := root.right;
            root.parent := null;
            free(root);
            res.parent := p;
            return res;
        } else {
            var l: Node, m: Node;
            l, m := extract_max(root.left, root, lb, value - 1);
            m.left := l;
            if (l != null) {       
              l.parent := m;
            }
            m.right := root.right;
            m.right.parent := m;
            root.parent := null;
            free(root);
            m.parent := p;
            return m;
        }
    } else if (root.data > value) {
        root.left := remove(root.left, value, root, lb, root.data - 1);
        return root;
    } else {
        root.right := remove(root.right, value, root, root.data + 1, ub);
        return root;
    }
}
