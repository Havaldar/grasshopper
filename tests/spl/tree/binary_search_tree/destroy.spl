struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate bstree_cnt(x: Node, y: Node, lb: int, ub: int, content: set<int>) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    lb <= x.data &*&
    x.data <= ub &*&
    bstree_cnt(x.left, x, lb, x.data - 1, content) &*&  //TODO content
    bstree_cnt(x.right, x, x.data + 1, ub, content)     //TODO content
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure destroy(root: Node, p: Node,
                  ghost lb: int, ghost ub: int,
                  implicit ghost content: set<int>)
  requires bstree_cnt(root, p, lb, ub, content);
  requires treeAllocInvariant(Alloc);
  ensures treeAllocInvariant(Alloc);
  ensures bstree_cnt(null, null, lb, ub, set<int>());
{
    if (root != null) {
        destroy(root.left, root, lb, ub);
        destroy(root.right, root, lb, ub);
        root.parent := null;
        free root;
    }
}

