include "../include/bstree.spl";

procedure contains(root: Node, val: Int, implicit ghost content: Set<Int>)
  returns (res: Bool)
  requires tree_set(root, content)
  ensures  tree_set(root, content)
  ensures  res == val in content
{
  if (root == null) {
    return false;
  } else { 
    if (val == root.data) {
      return true;
    } else if (val < root.data) {
      res := contains(root.left, val);
      if (root.left != null) {root.left.parent := root;}
      return res;
    } else {
      res := contains(root.right, val);
      if (root.right != null) {root.right.parent := root;}
      return res;
    }
  }
}

procedure destroy(root: Node, implicit ghost content: Set<Int>)
  requires tree_set(root, content);
  ensures emp;
{
  if (root != null) {
    destroy(root.left);
    destroy(root.right);
    root.parent := null;
    free root;
  }
}

procedure traverse(root: Node, implicit ghost content: Set<Int>)
  requires tree_set(root, content);
  ensures tree_set(root, content);
{
  if (root != null) {
    traverse(root.left);
    if (root.left != null) {root.left.parent := root;}
    traverse(root.right);
    if (root.right != null) {root.right.parent := root;}
  }
}

procedure extract_max(root: Node, implicit ghost content: Set<Int>)
returns (new_root: Node, max: Node)
  requires tree_set(root, content) &*& root != null
  ensures tree_set(new_root, content -- Set(max.data)) &*& acc(max)
  ensures max.right == null && max.parent == null && max.data in content
  ensures (forall z in (content -- Set(max.data)) :: z < max.data)
{
  if (root.right != null) {
    var c: Node, m: Node;
    c, m := extract_max(root.right); 
    root.right := c;
    if (c != null) { c.parent := root; }
    return root, m;
  } else {
    var c := root.left;
    root.parent := null;
    return c, root;
  }
}

procedure insert(root: Node, value: Int, implicit ghost content: Set<Int>)
  returns (new_root: Node)
  requires tree_set(root, content)
  ensures  tree_set(new_root, content ++ Set(value))
{
  if (root == null) {
    var t := new Node;
    t.left := null;
    t.right := null;
    t.data := value;
    return t;
  } else { 
    var n: Node;
    if (root.data > value) {
      n := insert(root.left, value);
      root.left := n;
      if (n != null) {n.parent := root;}
      return root;
    } else if (root.data < value) {
      n := insert(root.right, value);
      root.right := n;
      if (n != null) {n.parent := root;}
      return root;
    }
    return root;
  }
}

procedure remove(root: Node, value: Int, implicit ghost content: Set<Int>)
  returns (res: Node)
  requires tree_set(root, content)
  ensures tree_set(res, content -- Set(value))
{
  if (root == null) {
    return null;
  } else if (root.data == value) {
    if (root.left == null && root.right == null) {
      root.parent := null;
      free(root);
      return null;
    } else if (root.left != null && root.right == null) {
      res := root.left;
      root.parent := null;
      res.parent := null;
      free(root);
      return res;
    } else if (root.left == null && root.right != null) {
      res := root.right;
      root.parent := null;
      res.parent := null;
      free(root);
      return res;
    } else {
      root.parent := null;
      var l: Node, m: Node;
      l, m := extract_max(root.left);
      m.left := l;
      if (l != null) { l.parent := m; }
        m.right := root.right;
        m.right.parent := m;
        free(root);
        return m;
      }
  } else if (root.data > value) {
    root.left := remove(root.left, value);
    if (root.left != null) {root.left.parent := root;}
    return root;
  } else {
    root.right := remove(root.right, value);
    if (root.right != null) {root.right.parent := root;}
    return root;
  }
}

procedure rotate_left(h: Node, implicit ghost content: Set<Int>) 
  returns (res: Node)
  requires tree_set(h, content)
  requires h != null && h.right != null
  ensures  tree_set(res, content)
{
  var x: Node;
  x := h.right;
  h.right := x.left;
  if (h.right != null) h.right.parent := h;
  x.left := h;
  x.left.parent := x;
  x.parent := null;
  return x;
}

procedure rotate_right(h: Node, implicit ghost content: Set<Int>) 
  returns (res: Node)
  requires tree_set(h, content)
  requires h != null && h.left != null
  ensures  tree_set(res, content)
{
  var x: Node;
  x := h.left;
  h.left := x.right;
  if (h.left != null) h.left.parent := h;
  x.right := h;
  x.right.parent := x;
  x.parent := null;
  return x;
}
