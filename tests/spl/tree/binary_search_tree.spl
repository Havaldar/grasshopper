struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate stree(x: Node, y: Node, content: set<int>) {
    x == null &*&
    content == set<int>()
  ||
    x != null &*&
    x.parent |-> y &*&
    x.data in content &*&
    stree(x.left, x, content) &*&  //TODO content
    stree(x.right, x, content)     //TODO content
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure contains(root: Node, val: int, p: Node,
                   implicit ghost content: set<int>)
  returns (res: bool)
  requires stree(root, p, content);
  requires treeAllocInvariant(Alloc);
  ensures  treeAllocInvariant(Alloc);
  ensures  stree(root, p, content);
  ensures  res == val in content;
{
  if (root == null) {
    return false;
  } else { 
    if (val == root.data) {
      return true;
    } else if (val < root.data) {
      return contains(root.left, val, root);
    } else {
      return contains(root.right, val, root);
    }
  }
}

procedure destroy(root: Node, p: Node,
                  implicit ghost content: set<int>)
  requires stree(root, p, content);
  requires treeAllocInvariant(Alloc);
  ensures treeAllocInvariant(Alloc);
{
    if (root != null) {
        destroy(root.left, root);
        destroy(root.right, root);
        root.parent := null;
        free root;
    }
}

procedure traverse(root: Node, p: Node,
                   implicit ghost content: set<int>)
  requires stree(root, p, content);
  requires treeAllocInvariant(Alloc);
  ensures  treeAllocInvariant(Alloc);
  ensures  stree(root, p, content);
{
  if (root != null) {
    traverse(root.left, root);
    traverse(root.right, root);
  }
}

procedure extract_max(root: Node, ghost p: Node,
                      implicit ghost content: set<int>)
returns (others: Node, max: Node)
  requires stree(root, p, content) &*& root != null;
  requires treeAllocInvariant(Alloc);
  ensures  stree(others, p, content -- set(max.data)) &*& acc(max);
  ensures  max.right == null && max.parent == null && max.data in content;
  ensures  (forall z in (content -- set(max.data)) :: z < max.data);
  ensures  treeAllocInvariant(Alloc);
{
    if (root.right != null) {
        var c: Node, m: Node;
        c, m := extract_max(root.right, root); 
        root.right := c;
        return root, m;
    } else {
        var c: Node;
        c := root.left;
        root.parent := null;
        if (c != null) {
          c.parent := p;
        }
        return c, root;
    }
}

procedure insert(root: Node, value: int, p: Node,
                 implicit ghost content: set<int>)
returns (new_root: Node)
  requires stree(root, p, content);
  requires p == null || p in Alloc;
  requires treeAllocInvariant(Alloc);
  ensures treeAllocInvariant(Alloc);
  ensures stree(new_root, p, content ++ set(value));
{
  if (root == null) {
    var t: Node;
    t := new Node;
    t.left := null;
    t.right := null;
    t.parent := p;
    t.data := value;
    return t;
  } else { 
    if (root.data > value) {
      root.left := insert(root.left, value, root);
      return root;
    } else if (root.data < value) {
      root.right := insert(root.right, value, root);
      return root;
    }
    return root;
  }
}

procedure remove(root: Node, value: int, ghost p: Node,
                 implicit ghost content: set<int>)
returns (res: Node)
  requires stree(root, p, content);
  requires treeAllocInvariant(Alloc);
  ensures stree(res, p, content -- set(value));
  ensures treeAllocInvariant(Alloc);
{
    if (root == null) {
        return null;
    } else if (root.data == value) {
        if (root.left == null && root.right == null) {
            root.parent := null;
            free(root);
            return null;
        } else if (root.left != null && root.right == null) {
            res := root.left;
            root.parent := null;
            free(root);
            res.parent := p;
            return res;
        } else if (root.left == null && root.right != null) {
            res := root.right;
            root.parent := null;
            free(root);
            res.parent := p;
            return res;
        } else {
            root.parent := null;
            var l: Node, m: Node;
            l, m := extract_max(root.left, root);
            m.left := l;
            if (l != null) {       
              l.parent := m;
            }
            m.right := root.right;
            m.right.parent := m;
            free(root);
            m.parent := p;
            return m;
        }
    } else if (root.data > value) {
        root.left := remove(root.left, value, root);
        return root;
    } else {
        root.right := remove(root.right, value, root);
        return root;
    }
}

procedure rotate_left(h: Node, ghost p: Node, implicit ghost content: set<int>) returns (res: Node)
  requires stree(h, p, content);
  requires h != null && h.right != null;
  requires treeAllocInvariant(Alloc);
  ensures  treeAllocInvariant(Alloc);
  ensures  stree(res, p, content);
{
    var x: Node;
    x := h.right;
    h.right := x.left;
    if (h.right != null) h.right.parent := h;
    x.left := h;
    if (x.left != null) x.left.parent := x;
    x.parent := p;
    return x;
}

procedure rotate_right(h: Node, ghost p: Node, implicit ghost content: set<int>) returns (res: Node)
  requires stree(h, p, content);
  requires h != null && h.left != null;
  requires treeAllocInvariant(Alloc);
  ensures  treeAllocInvariant(Alloc);
  ensures  stree(res, p, content);
{
    var x: Node;
    x := h.left;
    h.left := x.right;
    if (h.left != null) h.left.parent := h;
    x.right := h;
    if (x.right != null) x.right.parent := x;
    x.parent := p;
    return x;
}
