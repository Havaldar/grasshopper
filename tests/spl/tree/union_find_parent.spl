struct Node {
  var parent: Node;
}

predicate tree_set(root: Node, X: set<Node>) {
    root.parent == root.parent
    //TODO ...
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure find(x: Node, ghost root_x: Node, implicit ghost X: set<Node>) 
returns (res: Node)
  requires x in X &*& tree_set(root_x, X) &*& treeAllocInvariant(Alloc);
  ensures  res == root_x &*& tree_set(root_x, X) &*& treeAllocInvariant(Alloc);
{
  var n: Node;
  n := x.parent;
  if (n != null) {
    res := find(n, root_x);
    x.parent := res;
  } else {
    res := x;
  }
}

procedure union(x: Node, y: Node, ghost root_x: Node, ghost root_y: Node,
                implicit ghost X: set<Node>, implicit ghost Y: set<Node>)
  requires tree_set(root_x, X) &+& tree_set(root_y, Y);
  requires x in X &*& y in Y &*& treeAllocInvariant(Alloc);
  ensures  tree_set(root_y, X ++ Y) &*& treeAllocInvariant(Alloc);
{
  var t: Node, s: Node;
  t := find(x, root_x);
  s := find(y, root_y);
  if (t != s) {
    t.parent := s;
  }
}

procedure create() returns (res: Node)
  requires treeAllocInvariant(Alloc);
  ensures  tree_set(res, set(res)) &*& treeAllocInvariant(Alloc);
{
    var n: Node;
    n := new Node;
    return n;
}
