struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate bstree(x: Node, y: Node, lb: int, ub: int) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    lb <= x.data &*&
    x.data <= ub &*&
    bstree(x.left, x, lb, x.data) &*&
    bstree(x.right, x, x.data, ub)
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure insert(root: Node, value: int, p: Node,
                 ghost lb: int, ghost ub: int)
returns (new_root: Node)
  requires bstree(root, p, lb, ub);
  requires p == null || p in Alloc;
  requires lb <= value && value <= ub;
  requires treeAllocInvariant(Alloc);
  ensures treeAllocInvariant(Alloc);
  ensures bstree(new_root, p, lb, ub);
{
  if (root == null) {
    var t: Node;
    t := new Node;
    t.left := null;
    t.right := null;
    t.parent := p;
    t.data := value;
    return t;
  } else { 
    if (root.data > value) {
      root.left := insert(root.left, value, root, lb, root.data-1);
      return root;
    } else if (root.data < value) {
      root.right := insert(root.right, value, root, root.data+1, ub);
      return root;
    }
    return root;
  }
}
