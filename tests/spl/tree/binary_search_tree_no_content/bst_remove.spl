struct Node {
  var left: Node;
  var right: Node;
  var parent: Node;
  var data: int;
}

predicate stree(x: Node, y: Node) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    stree(x.left, x) &*&
    stree(x.right, x) &*&
    (x.left == null || (x.left != null && x.left.data < x.data)) &*&
    (x.right == null || (x.right != null && x.right.data > x.data)) 
}

predicate tree(x: Node, y: Node) {
    x == null
  ||
    x != null &*&
    x.parent |-> y &*&
    tree(x.left, x) &*&
    tree(x.right, x)
}

predicate treeAllocInvariant(X: set<Node>) {
  (forall n in X :: n.parent == n.parent)
}

procedure extract_max(root: Node, p: Node) returns (others: Node, max: Node)
  requires p in Alloc || p == null;
  requires tree(root, p) &*& root != null;
  requires treeAllocInvariant(Alloc);
  ensures  tree(others, p);
  ensures  acc(max) &*& max.left == null &*& max.right == null &*& max.parent == null;
  ensures  treeAllocInvariant(Alloc);

procedure remove(root: Node, value: int, p: Node) returns (res: Node)
  requires tree(root, p);
  requires treeAllocInvariant(Alloc);
  ensures tree(res, p);
  ensures treeAllocInvariant(Alloc);
{
    if (root == null) {
        return null;
    } else if (root.data == value) {
        if (root.left == null && root.right == null) {
            root.parent := null;
            free(root);
            return null;
        } else if (root.left != null && root.right == null) {
            res := root.left;
            root.parent := null;
            free(root);
            res.parent := p;
            return res;
        } else if (root.left == null && root.right != null) {
            res := root.right;
            root.parent := null;
            free(root);
            res.parent := p;
            return res;
        } else {
            var l: Node, m: Node;
            l, m := extract_max(root.left, root);
            m.left := l;
            if (l != null) {       
              l.parent := m;
            }
            m.right := root.right;
            if (root.right != null) {
              root.right.parent := m;
            }
            root.parent := null;
            free(root);
            m.parent := p;
            return m;
        }
    } else if (root.data > value) {
        root.left := remove(root.left, value, root);
        //if (root.left != null) {
        //  root.left.parent := root;
        //}
        return root;
    } else {
        root.right := remove(root.right, value, root);
        //if (root.right != null) {
        //  root.right.parent := root;
        //}
        return root;
    }
}
