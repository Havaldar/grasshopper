struct Node {
  var next: Node;
  var data: int;
}

predicate sorted_set_lb(x: Node, y: Node, lb: int, c: set<int>) {
    x == y &*&
    c == set<int>()
  || 
    x != y &*&
    acc(x) &*&
    x.data in c &*&
    lb < x.data &*&
    sorted_set_lb(x.next, y, x.data, c -- set(x.data))
}

predicate sorted_set(x: Node, y: Node, c: set<int>) {
    x == y &*&
    c == set<int>()
  || 
  sorted_set_lb(x, y, x.data - 1, c)
}

procedure insert( lst: Node, val: int, implicit ghost content: set<int>)
  returns (res: Node)
  requires sorted_set(lst, null, content);
  ensures sorted_set(res, null, content ++ set(val));
{
  var curr: Node, prev: Node;
  curr := lst;
  prev := null;
  var c1: set<int>, c2: set<int>;
  c1 := content;
  c2 := set<int>();
  while (curr != null && curr.data < val)
    invariant prev == null && curr == lst && c2 == set<int>() || 
                (val > prev.data && prev != curr && prev.next == curr && 
                Btwn(next,lst,prev,curr)) &*& sorted_set(lst, curr, c2);
    invariant sorted_set(curr, null, c1) &*& content == c1 ++ c2;
    invariant prev == null || curr == null || prev.data < curr.data;
  {
    c1 := c1 -- set(curr.data);
    c2 := c2 ++ set(curr.data);
    prev := curr;
    curr := curr.next; 
  }
  var n: Node;
  if (curr != null && curr.data == val) {
    return lst;
  }
  n := new Node;
  n.next := curr;
  n.data := val;
  if (prev != null) {
    prev.next := n;
    return lst;
  } else {
    return n;
  }
}
