include "../include/slsset.spl";

procedure delete( lst: Node, val: Int, implicit ghost content: Set<Int>)
  returns (res: Node)
  requires sorted_set(lst, null, content);
  ensures sorted_set(res, null, content -- Set(val));
{
    var curr: Node, prev: Node;
    curr := lst;
    prev := null;
    var c1: Set<Int>, c2: Set<Int>;
    c1 := content;
    c2 := Set<Int>();
    while (curr != null && curr.data < val)
      invariant prev == null && curr == lst && c2 == Set<Int>() || 
                  (val > prev.data && prev != curr && prev.next == curr && 
                  Btwn(next,lst,prev,curr)) &*& sorted_set(lst, curr, c2);
      invariant sorted_set(curr, null, c1) &*& content == c1 ++ c2;
      invariant prev == null || curr == null || prev.data < curr.data;
    {
        c1 := c1 -- Set(curr.data);
        c2 := c2 ++ Set(curr.data);
        prev := curr;
        curr := curr.next; 
    }
    if (curr != null && curr.data == val) {
        var n: Node;
        n := curr;
        curr := curr.next;
        free n;
        if (prev != null) {
            prev.next := curr;
            return lst;
        } else {
            return curr;
        }
    } else {
        return lst;
    }
}
