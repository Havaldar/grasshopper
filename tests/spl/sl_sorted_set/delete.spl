struct Node {
  var next: Node;
  var data: int;
}

predicate sorted_set(x: Node, y: Node, lb: int, ub: int, c: set<int>) {
    x == y &*&
    c == set<int>()
  || 
    x != y &*&
    acc(x) &*&
    x.data in c &*&
    lb <= x.data &*&
    x.data < ub &*&
    sorted_set(x.next, y, x.data + 1, ub, c -- set(x.data))
}

procedure delete( lst: Node, val: int,
                  ghost lb: int, ghost ub: int,
                  implicit ghost content: set<int>)
  returns (res: Node)
  requires sorted_set(lst, null, lb, ub, content);
  ensures sorted_set(res, null, lb, ub, content -- set(val));
{
    var curr: Node, prev: Node;
    curr := lst;
    prev := null;
    var c1: set<int>, c2: set<int>;
    c1 := content;
    c2 := set<int>();

    while (curr != null && curr.data < val)
        invariant (prev == null &*& sorted_set(curr, null, curr.data, ub, c2))
               || (prev.next |-> curr &*& prev.data < curr.data &*&
                   sorted_set(lst, prev, lb, prev.data - 1, c2) &*&
                   sorted_set(curr, null, curr.data, ub, c1));
        invariant content == c1 ++ c2;
    {
        c2 := c2 ++ set(curr.data);
        c1 := c1 ++ set(curr.data);
        prev := curr;
        curr := curr.next; 
    }

    if (curr != null && curr.data == val) {
        var n: Node;
        n := curr;
        curr := curr.next;
        free n;
        if (prev != null) {
            prev.next := curr;
            return lst;
        } else {
            return curr;
        }
    } else {
        return lst;
    }

}
