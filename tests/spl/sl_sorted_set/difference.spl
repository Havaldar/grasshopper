struct Node {
  var next: Node;
  var data: Int;
}

predicate sorted_set_lb(x: Node, y: Node, lb: Int, c: Set<Int>) {
    x == y &*&
    c == Set<Int>()
  || 
    x != y &*&
    acc(x) &*&
    x.data in c &*&
    lb < x.data &*&
    sorted_set_lb(x.next, y, x.data, c -- Set(x.data))
}

predicate sorted_set(x: Node, y: Node, c: Set<Int>) {
    x == y &*&
    c == Set<Int>()
  || 
  sorted_set_lb(x, y, x.data - 1, c)
}

procedure difference(lst1: Node, lst2: Node,
                implicit ghost content1: Set<Int>, implicit ghost content2: Set<Int>)
  returns (res: Node)
  requires sorted_set(lst1, null, content1) &*& sorted_set(lst2, null, content2);
  ensures sorted_set(lst2, null, content2) &*& sorted_set(res, null, content1 -- content2);
{
    if (lst1 == null) {
        return lst1;
    } else if (lst2 == null) {
        return lst1;
    } else if (lst1.data < lst2.data) {
        lst1.next := difference(lst1.next, lst2);
        return lst1;
    } else if (lst1.data > lst2.data) {
        return difference(lst1, lst2.next);
    } else { //lst1.data == lst2.data
        var n: Node;
        n := lst1.next;
        free lst1 ;
        return difference(n, lst2.next);
    }
}
