method merge(a, b)
    requires slseg(a, null) * slseg(b, null);
    ensures slseg(returned, null);
{
    head := null;
    if (a == null) {
        return b;
    } else if (b == null) {
        return a;
    } else if (a.data <= b.data) {
        head := a;
        a := a.next;
    } else {
        head := b;
        b := b.next;
    }
    last := head;
    while (a != null || b != null)
        invariant (last |-> a || last |-> b) * lslseg(head, last, last) * uslseg(a, null, last) * uslseg(b, null, last);
    {
        if (a == null || (b != null && a.data > b.data)) {
            last.next := b;
            last := b;
            b := b.next;
        } else {
            last.next := a;
            last := a;
            a := a.next;
        }
    }
    return head;
}

method length(x)
    requires lseg(x, null);
    ensures lseg(x, null);
{
    i := 0;
    curr := x;
    while (curr != null)
        invariant lseg(x,curr) * lseg(curr, null);
    {
        curr := curr.next;
        i := i+1;
    }
    return i;
}

method take(x, n, y)
    requires lseg(x, null) * y == null;
    ensures lseg(x, null) * lseg(y, null);
{
    y := x;
    while (y != null && n > 1)
        invariant lseg(x, y) * lseg(y, null);
    {
        y := y.next;
        n := n-1;
    }
    if (y != null) {
        tmp := y;
        y := y.next;
        tmp.next := null;
    }
}

method merge_sort(lst)
    requires lseg(lst, null);
    ensures slseg(returned, null);
{
    if (lst == null || lst.next == null) {
        return lst;
    } else {
        n := length(lst);
        n2 := n / 2;
        lst2 := null;
        take(lst, n2, lst2);
        //assert lseg(lst, null) * lseg(lst2, null);
        a := merge_sort(lst);
        //assert slseg(a, null) * lseg(lst2, null);
        b := merge_sort(lst2);
        //assert slseg(a, null) * slseg(b, null);
        merged := merge(a, b);
        return merged;
    }
}
