
method predecessor(start, end)
    requires lseg(start, end) * start != end;
    ensures lseg(start, returned) * returned |-> end;
{
    prv := start;
    curr := start.next;
    while (curr != end)
        invariant lseg(start, prv) * lseg(curr, end) * prv |-> curr;
    {
        prv := curr;
        curr := curr.next;
    }
    return prv;
}

method quicksort(lst, end, lb, ub)
    requires blseg(lst, end, lb, ub);
    ensures bslseg(lst, end, lb, ub);
{
    if (lst == end || lst.next == end) {
    } else {
        middle := split(lst, end);
        quicksort(lst, middle, lb, middle);
        quicksort(middle, end, middle, ub);
    }
}

method split(lst, tsl)
    requires lseg(lst, tsl) * lst != tsl;
    ensures llseg(lst, returned, returned) * ulseg(returned, tsl, returned);
{
    last := predecessor(lst, pivot);
    start := lst;
    end := last;
    while (start != end)
        invariant llseg(lst, start, pivot) * lseg(start, end) * ulseg(end, last, pivot) * last |-> pivot * pivot |-> x; 
    {
        tmp := 0; //for the typer ...
        if (start.data <= pivot.data) {
            start := start.next;
        } else if (end.data > pivot.data) {
            end := predecessor(start, end);
        } else {
            tmp := start.data;
            start.data := end.data;
            end.data := tmp;
        }
    }
    if (start == last) {
        return lst;
    } else if (start == lst) {
        return pivot;
    } else {
        last.next := pivot.next;
        pivot.next := start.next;
        start.next := pivot;
        return lst;
    }
}
