
method predecessor(start, end)
    requires lseg(start, end) * start != end * (end |-> x || end == null);
    ensures lseg(start, returned) * returned |-> end * (end |-> x || end == null);
{
    prv := start;
    curr := start.next;
    while (curr != end)
        invariant lseg(start, prv) * prv |-> curr * lseg(curr, end) * (end |-> x || end == null);
    {
        prv := curr;
        curr := curr.next;
    }
    assert lseg(start, prv) * prv |-> curr * lseg(curr, end) * (end |-> x || end == null) * curr == end;
    return prv;
}

method split(lst, pivot)
    requires lseg(lst, pivot) * pivot |-> x * lst != pivot;
    ensures llseg(returned, pivot, pivot) * ulseg(pivot, x, pivot);
{
    last := predecessor(lst, pivot);
    start := lst;
    end := last;
    while (start != end)
        invariant llseg(lst, start, pivot) * lseg(start, end) * ulseg(end, pivot, pivot);
    {
        if (start.data <= pivot.data) {
            start := start.next;
        } else if (end.data > pivot.data) {
            end := predecessor(start, end);
        } else {
            tmp := start.data;
            start.data := end.data;
            end.data := tmp;
        }
    }
    if (start != last) {
       last.next := pivot.next;
       pivot.next := start;
    } else {}
    if (start == lst) {
       return pivot;
    } else {
       return start;
    }
}

method quicksort(lst, end)
    requires lseg(lst, end) * (end |-> x || end == null);
    ensures slseg(lst, end) * (end |-> x || end == null);
{
    if (lst == end || lst.next == end) {
    } else {
        pivot := predecessor(lst, end);
        split(lst, pivot);
        quicksort(lst, pivot);
        quicksort(pivot, end);
    }
}
